import applyReleasePlan from "@changesets/apply-release-plan";
import { read } from "@changesets/config";
import getReleasePlan from "@changesets/get-release-plan";
import getChangesets from "@changesets/read";
import { getPackages } from "@manypkg/get-packages";
import { IGitApi } from "azure-devops-node-api/GitApi";
import {
  CommentThreadStatus,
  GitChange,
  GitPullRequest,
} from "azure-devops-node-api/interfaces/GitInterfaces";
import * as child_process from "child_process";
import fs from "fs-extra";
import { join } from "path";
import { CommitResult, PushResult } from "simple-git";
import { promisify } from "util";
import { getChangelogEntry } from "../utilities";
import { GitManager } from "./git-manager";
import ThreadManager from "./thread-manager";

type Result = {
  passed: boolean;
  threadId?: number;
};

export type ChangeBotCheckResult = {
  passed: boolean;
  threads: number[];
};

const exec = promisify(child_process.exec);

/**
 * ChangeBot manages all Changeset and Changelog checks.
 *
 */
export default class ChangeBot {
  private api: IGitApi;
  private pr: GitPullRequest;
  private threads: ThreadManager;
  private git: GitManager;
  private files: string[];

  constructor(api: IGitApi, pr: GitPullRequest, auth?: string) {
    this.api = api;
    this.pr = pr;
    this.threads = new ThreadManager(api, pr);
    this.git = new GitManager(auth);
    this.files = [];
  }

  public async check(): Promise<ChangeBotCheckResult> {
    // step 1: check for changeset
    const check1 = await this.checkForChangeset();

    // step 2: if there are changesets, generate
    // changelog and version package.
    if (check1.passed) {
      await this.git.initialize(this.pr);

      console.info("Generating Changelog");
      const check2 = await this.generateChangelog();

      return {
        passed: check1.passed && check2.passed,
        threads: [check1.threadId, check2.threadId],
      };
    }

    return {
      passed: check1.passed,
      threads: [check1.threadId],
    };
  }

  /**
   * Get a list of all changed files
   *
   * @returns an array of all changed file names
   */
  private async updateChangedFiles() {
    for (const c of this.pr.commits) {
      const changes: GitChange[] = (
        await this.api.getChanges(c.commitId, this.pr.repository.id)
      ).changes;

      this.files.push(...changes.map((f) => f.item?.path));
    }
  }

  /**
   * Checks the repository of the pull request for changesets.
   *
   * @returns `{ passed: true, threadId: <id>}` if passed,
   *          else `{ passed: false, threadId: <id>}`
   */
  private async checkForChangeset(): Promise<Result> {
    // TODO: rewrite to checkout branch and parse changeset using @changeset/read

    // make sure the list of changed files is up to date
    await this.updateChangedFiles();

    // check for changeset files
    const changesetFiles = this.files
      .filter((f) => f.includes("/.changeset"))
      .map((f) => f.replace("/.changeset/", ""));

    // find unique changesets
    const changesets = Array.from(
      new Set(changesetFiles.filter((f) => f.split("-").length === 3)).values()
    );

    const passed = changesets.length > 0;

    let title = "";
    let description = "";
    const footer =
      "> ChangeBot looks at Pull Requests to find files generated by [@changesets/cli](https://github.com/changesets/changesets). If you feel like there is an issue, you can override the branch policy requirements, but proceed with caution.";

    if (passed) {
      title = "# Changeset Check Passed âœ…\n";

      description = "ChangeBot was able to find the following changeset(s):\n";
      description += changesets.map((r) => `- \`${r}\`\n`).join("");
    } else {
      title = "# Changeset Check Failed âŒ\n";
      description =
        "Changeset Bot was unable to find changeset files, and detected changes to source code in the PR.\nPlease commit your changeset to the PR to pass this check.\n";
    }

    const content = [title, description, footer].join("");

    // generate thread comment from changeset result
    const thread = await this.threads.upsertThread(
      content,
      (t) =>
        t?.comments?.find((c) => c?.content?.includes("# Changeset Check")) !=
        null
    );

    // if the check was passed, set the thread status to closed.
    passed
      ? this.threads.setThreadStatus(thread, CommentThreadStatus.Closed)
      : this.threads.setThreadStatus(thread, CommentThreadStatus.Active);

    return {
      passed: passed,
      threadId: thread.id,
    };
  }

  /**
   * Generate a changelog entry for the given changes.
   *
   * @returns `{ passed: true, threadId: <id> }` if able to generate, `{ passed: false, threadId: <id> }` otherwise.
   */
  private async generateChangelog(): Promise<Result> {
    // these files will _always_ be changed by the `yarn changeset version` function.
    // the actual changeset files will have to be determined programatically.
    const files = ["CHANGELOG.md", "package.json"];

    await this.git.checkout();

    const changesets = await getChangesets(this.git.dir);
    const releasePlan = await getReleasePlan(this.git.dir, "master");
    const packages = await getPackages(this.git.dir);
    const config = await read(this.git.dir, packages);

    await applyReleasePlan(releasePlan, packages, config);

    // push the changeset names ot the files list to be added to
    // git index.
    files.push(...changesets.map((c) => `.changeset/${c.id}.md`));
    await this.git.add(files);

    // commit and push the changes
    const commitResult: CommitResult = await this.git.commit(
      "chore(changelog): generate changelog"
    );
    const pushResult: PushResult = await this.git.push();

    // get our package information so we can parse the
    // changelog for the new entry
    const pkg = require(join(this.git.dir, "package.json"));
    const changelog = await fs.readFile(
      join(this.git.dir, "CHANGELOG.md"),
      "utf-8"
    );

    const changeLogContents = await getChangelogEntry(changelog, pkg.version);

    // once we are done, remove the repository.
    await exec(`rm -rf ${this.pr.repository.name}`);

    let title = "";
    let description = "";
    const footer =
      "> ChangeBot looks at Pull Requests to find files generated by [@changesets/cli](https://github.com/changesets/changesets). If you feel like there is an issue, you can override the branch policy requirements, but proceed with caution.";

    if (pushResult != null) {
      // generate thread containing success status, and SHA reference
      title = "# Changelog Generated âœ…\n";

      description = `ChangeBot committed the following changes:\n${files
        .map((f) => `- \`${f}\`\n`)
        .join("")}`;

      description += `\nPlease reference SHA \`${commitResult.commit}\`\n`;
    } else {
      // generate thread containing failure status, and error message
      title = "# Changelog Generation Failed ðŸ‘Ž\n";

      description = `ChangeBot was unable to generate a changelog for these changes.`;
      description +=
        "Please consult the error above modify the PR to resolve any issues.";
    }

    const content = [title, description, footer].join("");
    const thread = await this.threads.upsertThread(content, (t) => {
      return (
        t?.comments?.find((c) => c?.content?.includes("# Changelog")) != null
      );
    });

    // if the changelog generation was successful, comment on the success thread
    // with the contents of the changelog.
    if (changeLogContents.content != null) {
      const content = `## v${pkg.version}\n${changeLogContents.content}`;
      await this.threads.postComment(thread, content);
    }

    // if changelog generation was successful, set thread status as closed.
    pushResult != null
      ? await this.threads.setThreadStatus(thread, CommentThreadStatus.Closed)
      : await this.threads.setThreadStatus(thread, CommentThreadStatus.Active);

    return {
      passed: pushResult != null,
      threadId: thread.id,
    };
  }
}
